[{"title":"Installation Guide","type":0,"sectionRef":"#","url":"/babylon-test/installation","content":"","keywords":""},{"title":"Step 1: Install Golang ​","type":1,"pageTitle":"Installation Guide","url":"/babylon-test/installation#step-1-install-golang-","content":"Note Babylon requires golang version 1.18 for Babylon to be installed on your system. Install Golang on your system by following the steps below: Go to Golang official website and grab the tarball link of the golang version you want to use. Or use the following wget command to download and install Golang: sudo wget https://go.dev/dl/go1.19.4.linux-amd64.tar.gz  Extract the tarball to /usr/local directory by using the code below: sudo tar -C /usr/local -xzf go1.19.4.linux-amd64.tar.gz  For the system-wide installation, add the go binary path to .bashrc file /etc/profile by using the code below: export PATH=$PATH:/usr/local/go/bin  Then, run the code below to apply the change: source ~/.bashrc  Run the code below to check if Golang has been successfully installed: go version  It will return the Golang version that you have installed. go version go1.19.4 linux/amd64  "},{"title":"Step 2: Clone Babylon Repository ​","type":1,"pageTitle":"Installation Guide","url":"/babylon-test/installation#step-2-clone-babylon-repository-","content":"You need to clone Babylon’s GitHub repository to install the Node. Follow the steps below to clone Babylon’s repository: Open a folder to place the cloned file from the repository. Insert the following code: cd /mnt/c/Users/(YourSystemUsername)/Documents/Babylon  Note Change the YourSystemUsername into your System Username. Clone the repository by using the following code below: git clone https://&lt;tokenhere&gt;@github.com/babylonchain/babylon.git  Note Replace tokenhere with your own unique access token. Enter your GitHub username and password for the Github authentication process. Successfully cloned the repository. "},{"title":"Step 3: Initialize the Babylon Chain ​","type":1,"pageTitle":"Installation Guide","url":"/babylon-test/installation#step-3-initialize-the-babylon-chain-","content":"After cloning the Babylon repository, you must create the Babylon chain to start the Node. Follow the steps below to create the Babylon Chain: Open the cloned repository folder on your system: cd /mnt/c/Users/(YourSystemUsername)/Documents/Babylon/babylond  Install Make by inserting the code below: sudo apt install make  Build the chain by inserting the code below on Ubuntu: make build  It would return as follows: go build -mod=readonly -tags &quot;netgo ledger&quot; -ldflags '-X github.com/cosmos/cosmos-sdk/version.Name=babylon -X github.com/cosmos/cosmos-sdk/version.AppName=babylond -X github.com/cosmos/cosmos-sdk/version.Version=00924d4 -X github.com/cosmos/cosmos-sdk/version.Commit=00924d4e2cc401bdff89e6489ae301e00a865880 -X &quot;github.com/cosmos/cosmos-sdk/version.BuildTags=netgo,ledger&quot; -w -s' -trimpath -o /mnt/c/Users/kakakepan/Documents/Babylond/babylon/build/ ./...  Under the babylond build directory, a babylon executable will be created. To install the Babylon executable to the Babylon chain, insert the code below: make install  It would return as follows: go install -mod=readonly -tags &quot;netgo ledger&quot; -ldflags '-X github.com/cosmos/cosmos-sdk/version.Name=babylon -X github.com/cosmos/cosmos-sdk/version.AppName=babylond -X github.com/cosmos/cosmos-sdk/version.Version=00924d4 -X github.com/cosmos/cosmos-sdk/version.Commit=00924d4e2cc401bdff89e6489ae301e00a865880 -X &quot;github.com/cosmos/cosmos-sdk/version.BuildTags=netgo,ledger&quot; -w -s' -trimpath ./...  Initialize the chain by inserting the code below: $ ./build/babylond init chainName  Note You may replace the chainName with any desired name. After the Babylon chain has been successfully initialized, a directory named ~/.babylond will be created, allowing users to choose a different home directory with the --home flag. "},{"title":"chainbuilding","type":0,"sectionRef":"#","url":"/babylon-test/chainbuilding","content":"","keywords":""},{"title":"Requirements​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#requirements","content":"Go 1.18 "},{"title":"Development requirements​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#development-requirements","content":"Go 1.18Docker "},{"title":"Building​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#building","content":"To build the chain, simply: make build  This will lead to the creation of a babylond executable under the builddirectory. "},{"title":"Installing​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#installing","content":"To build the chain and install a babylon executable: make install  "},{"title":"Testing​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#testing","content":"make test  "},{"title":"Running a node​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#running-a-node","content":"The following commands assume that the babylond executable has been installed. If the repository was only built, then ./build/babylond should be used in its place. "},{"title":"Generating the node configuration​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#generating-the-node-configuration","content":"The configuration for a single node can be created through the testnetcommand. While the testnet command can create an arbitrary number of nodes that communicate on a testnet, here we focus on the setup of a single node. babylond testnet \\ --v 1 \\ --output-dir ./.testnet \\ --starting-ip-address 192.168.10.2 \\ --keyring-backend test \\ --chain-id chain-test  The flags specify the following: --output-dir &lt;testnet-dir&gt;: Specifies that the testnet files should reside under this directory.--v &lt;N&gt;: Leads to the creation of N nodes, each one residing under the&lt;testnet-dir&gt;/node{i}. In this case i={0..N-1}.--starting-ip-address &lt;ip&gt;: Specifies the IP address for the nodes. For example,192.168.10.2 leads to the first node running on 192.168.10.2:46656, the second one on 192.168.10.3:46656 etc.--keyring-backend {os,file,test}: Specifies the backend to use for the keyring. Available choices include os, file, and test. We use test for convenience.--chain-id: An identifier for the chain. Useful when perrforming operations later. In this case, we generated a single node. If we take a look under .testnet: $ ls .testnet gentxs node0  The gentxs directory contains the genesis transactions. It contains transactions that assign bbn tokens to a single address that is defined for each node. The node0 directory contains the the following, $ ls .testnet/node0/babylond config data key_seed.json keyring-test  A brief description of the contents: config: Contains the configuration files for the node.data: Contains the database storage for the node.key_seed.json: Seed to generate the keys maintained by the keyring.keyring-test: Contains the test keyring. This directory was created because we provided the --keyring-backend test flag. The testnet command, creates a validator node named node{i} (depends on the node name), and assigns bbn tokens to it through a transaction written to .testnet/gentxs/node{i}.json. The keys for this node can be pointed to by the node{i} name. "},{"title":"Running the node​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#running-the-node","content":"babylond start --home ./.testnet/node0/babylond  "},{"title":"Logs​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#logs","content":"The logs for a particular node can be found under.testnets/node{id}/babylond/babylond.log. "},{"title":"Performing queries​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#performing-queries","content":"After building a node and starting it, you can perform queries. babylond --home .testnet/node{i}/babylond/ --chain-id &lt;chain-id&gt; \\ query &lt;module-name&gt; &lt;query-name&gt;  For example, in order to get the hashes maintained by the btcligthclientmodule: $ babylond --home .testnet/node0/babylond/ --chain-id chain-test query btclightclient hashes hashes: - 00000000000000000002bf1c218853bc920f41f74491e6c92c6bc6fdc881ab47 pagination: next_key: null total: &quot;1&quot;  "},{"title":"Submitting transactions​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#submitting-transactions","content":"After building a node and running it, one can send transactions as follows: babylond --home .testnet/node{i}/babylond --chain-id &lt;chain-id&gt; \\ --keyring-backend {os,file,test} --fees &lt;amount&gt;&lt;denom&gt; \\ --from &lt;key-name&gt; --broadcast-mode {sync,async,block} \\ tx &lt;module-name&gt; &lt;tx-name&gt; [data]  The --fees flag specifies the amount of fees that we are willing to pay and the denomination and the --from flag denotes the name of the key that we want to use to sign the transaction (i.e. from which account we want this transaction to happen). The --broadcast-mode specifies how long we want to wait until we receive a response from the CLI: async means immediately,sync means after the transaction has been validated through CheckTx, and block means after the transaction has been processed by the next block. For example, in the btclightclient module, in order to submit a header, one should: babylond --home .testnet/node0/babylond --chain-id chain-test \\ --keyring-backend test --fees 100bbn \\ --from node0 --broadcast-mode block \\ tx btclightclient insert-header &lt;header-hex&gt;  "},{"title":"Running a multi-node testnet​","type":1,"pageTitle":"chainbuilding","url":"/babylon-test/chainbuilding#running-a-multi-node-testnet","content":"We provide support for running a multi-node testnet using Docker. To build it make localnet-start  The corresponding node directories can be found under .testnets $ ls .testnets gentxs node0 node1 node2 node3  "},{"title":"Error Handling","type":0,"sectionRef":"#","url":"/babylon-test/error","content":"","keywords":""},{"title":"Error During Repository Cloning ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#error-during-repository-cloning-","content":""},{"title":"Too Many Arguments ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#too-many-arguments-","content":"fatal: Too many arguments.  This error occurs when something is wrong with the git clone syntax on your Ubuntu. Solution: ​ Please make sure that the syntax is correct. Here is an example of the correct syntax to clone a git repository: git clone https://qa12345678910@github.com/babylonchain/babylon.git  Note Do not forget to create your personal access token to clone a git repository. "},{"title":"Could Not Set 'core.filemode' to 'false' ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#could-not-set-corefilemode-to-false-","content":"fatal: could not set 'core.filemode' to 'false'  This error occurs when the Windows Linux System permission within the drive is denied. Solution: ​ Restarting the system will reset the permissions. If this doesn't work, add Sudo to the syntax, as illustrated in the following code: sudo git clone https://qa12345678910@github.com/babylonchain/babylon.git  "},{"title":"Error During Babylon Chain Initialization ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#error-during-babylon-chain-initialization-","content":""},{"title":"No Such Directory Found ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#no-such-directory-found-","content":"No such file or directory  This issue happens when a make syntax is executed in the incorrect directory or path. Solution: ​ Remember to access the cloned repository folder to initialize the Babylon Chain after cloning the repository. Here is an example of a configuration code: cd /mnt/c/Users/&lt;yourusername&gt;/Documents/Babylond/babylon  "},{"title":"Command 'make' Not Found ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#command-make-not-found-","content":"Command 'make' not found  This occurs while building a chain without first installing the Make language. Solution: ​ Install the Make language on Ubuntu by inserting the code below: sudo apt install make  "},{"title":"Make Build Error 1 ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#make-build-error-1-","content":"go build -mod=readonly -tags &quot;netgo ledger&quot; -ldflags '-X github.com/cosmos/cosmos-sdk/version.Name=babylon -X github.com/cosmos/cosmos-sdk/version.AppName=babylond -X github.com/cosmos/cosmos-sdk/version.Version=af24cf3 -X github.com/cosmos/cosmos-sdk/version.Commit=af24cf321f848619739fafa7c1f6173b0284e61f -X &quot;github.com/cosmos/cosmos-sdk/version.BuildTags=netgo,ledger&quot; -w -s' -trimpath -o /mnt/c/Users/kakakepan/Documents/babylon/babylon/build/ ./... go: updates to go.mod needed, disabled by -mod=readonly make: *** [Makefile:116: build] Error 1  This occurs when a Golang version lower than 1.18 has been installed. Babylon requires Golang version 1.18 or above. Solution: ​ You need to uninstall Golang by inserting the code below on Ubuntu: sudo apt-get remove golang-go  Next, install the latest version of Golang by inserting the code below: sudo wget https://go.dev/dl/go1.19.4.linux-amd64.tar.gz sudo tar -C /usr/local -xzf go1.19.4.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin source ~/.bashrc  "},{"title":"Make Build Error 127 ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#make-build-error-127-","content":"make: *** [Makefile:116: build] Error 127  This occurs if the cloned repository already contains a Build directory when running Make Install on Ubuntu. Solution: ​ Go to the cloned repository directory.Remove the Build directory permanently.Insert the code below to create a new Build directory: make build  "},{"title":"Genesis File Already Exists ​","type":1,"pageTitle":"Error Handling","url":"/babylon-test/error#genesis-file-already-exists-","content":"Error: genesis.json file already exists  This occurs when a genesis file already exists when initializing the Babylon Chain. Solution: ​ Insert the code below to solve the genesis file error on Ubuntu: rm -r ~/.babylond  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/babylon-test/introduction","content":"","keywords":""},{"title":"1. Babylon Overview ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#1-babylon-overview-","content":"Babylon is a PoS (proof-of-stake) blockchain that provides secure Bitcoin timestamps to its transactions. Babylon is built using the Tendermint consensus engine and Cosmos SDK. It leverages cutting-edge cryptographic technologies and advanced Cosmos SDK features to send succinct, verifiable, and adversary-slashing checkpoints of the Babylon chain to BTC as BTC transactions. The BTC timestamps of Babylon checkpoints provide BTC-level security to all Babylon transactions. Below is a high-level architecture of the Babylon system. Babylon can be viewed as a checkpoint verifier and aggregator. It verifies and aggregates the checkpoints submitted by its users into ones that BTC can securely timestamp.  This primitive enables enormous security-related use cases for the decentralized world. One motivating and primary use case is to bring BTC security to PoS chains. "},{"title":"2. A Primary Usecase: Securing PoS Chains ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#2-a-primary-usecase-securing-pos-chains-","content":""},{"title":"2.1 Long-Range Attack: A Fundanmental Threat to PoS Chains ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#21-long-range-attack-a-fundanmental-threat-to-pos-chains-","content":"By PoS chains, we refer to BFT (Byzantine-fault-tolerent) PoS chains that require a 2/3 majority vote from their validators to confirm a block. PoS chains are not supposed to fork, and when forking happens, the chain is attacked: To have 2/3 majority vote for both forks, at least 1/3 of the validators have double-voted by signing both forks, which is a prohibited behavior by the consensus protocol. The picture below illustrates a forking attack to a hypothetical PoS chain called “Rugpull“.  To deter such attacks, most PoS chains only allow accounts who have bonded their tokens (a.k.a staking) to be validators. This way, if a validator is caught double signing, its bonded stake can be slashed by the consensus protocol in both forks, causing total economical loss to this malicious validator. This deterrence seems to provide slashable security to PoS chains. However, this requires the remaining validators to perceive both forks while the malicious validators are still bonded. Therefore, to avoid slashing, the malicious validators can first unbond from the first fork and then create the second fork from a block height where they are still validators. This way, the malicious validators will not be slashable in the first fork since they do not have a bonded stake. What’s even worse is that once the attack happens, new users of the PoS chain cannot tell which fork they should follow.  This attack is called the long-range attack, which renders PoS chains not slashable and secure. This attack is fundamental and cannot be solved by modifying the consensus protocol without an extra source of trust. To alleviate this threat, some PoS chains resort to social consensus, where the stakeholders periodically make off-chain decisions on the correct block at the latest height and ignore any other potential forks. However, this approach ties the chain's security to the participating stakeholders' subjective opinions. This approach is also called weak subjectivity, which is against the decentralization principle. In addition, since social consensus takes time, most PoS chains impose a very long stake unbonding time in the order of weeks. "},{"title":"2.2 Secure PoS using BTC timestamping ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#22-secure-pos-using-btc-timestamping-","content":" To protect the PoS chain from long-range attacks, we can checkpoint the PoS chain blocks to BTC, and implement a fork choice rule for the fork with an earlier BTC timestamp. This way, either The attacking fork will have a later BTC timestamp in the BTC canonical chain and will never be chosen by anyone, or In order to be chosen, the attacker will have to create a very long fork of BTC in which the attacking PoS fork has an earlier timestamp, which is economically impossible. Thus, long-range attacks are neutralized by BTC timestamping. "},{"title":"2.3 Benefits of BTC Timestamping to PoS Chains ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#23-benefits-of-btc-timestamping-to-pos-chains-","content":"Along with solving long-range attacks, the irreversible BTC timestamps of PoS blocks also provide other security benefits to PoS chains: No weak subjectivity: Bitcoin timestamps are objective. It can thus eliminate the dependency of PoS chains on social consensus and weak subjectivity. Shorter Unbonding Time: By replacing social consensus, BTC timestamping can reduce the stake unbonding time of PoS chains from weeks to one day. New Chain Bootstrapping: New PoS chains with low valuation are more vulnerable to forking attacks. BTC timestamping can help safeguard the chain alone its growth. Verification of State Sync and Snapshots: The objective truth about a PoS chain provided by BTC allows the users of the PoS chain to verify the chain state or snapshot it has downloaded from the P2P network. Protecting Important Transactions: BTC timestamps can be used to further confirm important PoS transactions at the cost of longer confirmation latency. Censorship Resistance: BTC timestamping could also be used to fight against transaction censorship in PoS chains via posting censored transactions to BTC. However, directly checkpointing to BTC is difficult and unscalable due to BTC’s tight space and expensive transaction fees. Moreover, BTC cannot verify the checkpointed data. This motivates the creation of Babylon, which solves all the difficulties with provable security. Note Without Babylon, it is difficult for any chain to directly checkpoint to Bitcoin due to scalability, cost, code modification, and security problems. "},{"title":"3. Key Components of Babylon ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#3-key-components-of-babylon-","content":" "},{"title":"Epoching ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#epoching-","content":"A new Cosmos app module for Babylon. It epoches the Babylon blocks, and within each epoch the validator set does not change. It achieves this by delaying the execution of validator-set-changing transactions to the last block of each epoch. This way, Babylon only needs to checkpoint one block per epoch to BTC, which reduces the checkpointing costs. "},{"title":"Checkpointing ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#checkpointing-","content":"A new Cosmos app module for Babylon. It collects the BLS signatures of Babylon validators on each block to be checkpointed and aggregate them into a BLS multiSig, and prepare a checkppoint accordingly. It then maintains the confirmation status of each checkpoint and the associated epoch according to the status provided by the btccheckpoint module. "},{"title":"Vigilante Submitter ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#vigilante-submitter-","content":"A standalone program that submits the Babylon checkpoints to BTC as BTC op_return transactions. "},{"title":"Vigilante Reporter ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#vigilante-reporter-","content":"A standalone program that scans BTC ledger for Babylon’s BTC checkpoints, and reports them back to Babylon as Babylon transactions. It also reports BTC headers to Babylon as Babylon transactions. "},{"title":"BTCCheckpoint ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#btccheckpoint-","content":"A new Cosmos app module for Babylon. It verifies the Babylon’s BTC checkpoints reported by the vigilante reporter, and provides the confirmation status of these checkpoints to the checkpointing module based on their depth according to the on chain BTC light client. "},{"title":"BTCLightClient ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#btclightclient-","content":"A new Cosmos app module for Babylon. This module maintains a BTC header chain and validates if a BTC block is part of the canonical BTC chain, its depth, and whether the inclusion evidence for a Bitcoin transaction is valid. "},{"title":"Vigilante Master Monitor ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#vigilante-master-monitor-","content":"A standalone program that monitors: The consistency between the realworld BTC caononical chain and the BTC header chain maintained by Babylon’s btclightclient module Whether all Babylon’s BTC checkpoints have been included in Babylon the ledger on time so that all Babylon nodes can see them. "},{"title":"IBC relayer ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#ibc-relayer-","content":"A standard Cosmos program that enables interchain communicaton. Its default client update function sends a Cosmos zone (CZ)'s headers to Babylon as Babylon transactions, making it a natural checkpointing mechanism. "},{"title":"IBC light client ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#ibc-light-client-","content":"A standard Cosmos app module residing in Babylon. It verifies the CZ headers shared by the IBC relayer and uses the verified CZ headers to further verify CZ transactions. "},{"title":"CZConcierge ​","type":1,"pageTitle":"Introduction","url":"/babylon-test/introduction#czconcierge-","content":"A new Cosmos app module for Babyon. It extracts verified CZ headers from the IBC light client and maintain their BTC-confirmaton status based on the BTC-confirmation status of the Babylon transactons that carry them. "}]